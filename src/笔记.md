##  mapreduce

master :

### 我的实现：

map任务执行完后，才分配reduce任务，map不需要排序，reduce的worker读进所有的中间文件后，用Key进行排序再执行reduce任务。

worker通过RPC调用向master请求任务，完成任务后通过commit提交信息。所有的worker和master会在所有任务结束后退出。

1. 定时任务，即计时10s开在一个新goroutine里
2. worker可以无状态，只要task有状态，master就能管理了
3. 临时文件很重要，否则存在一种可能，worker文件写好后发送给master的commit延迟了，此时master因为超时将任务分给了一个新worker，然后收到了延迟了的commit会将task标记改为Done，但新开的worker却修改了之前的文件。所以产生这种问题原因是，文件操作在master看来应该原子化，不应该存在中间态，所以用临时文件写完整后再原子的Rename

## Raft

**课上讲的两个注意的bug：**

1. RPC调用时不要加锁，得想办法在RPC调用前把锁释放，不然两个持有锁的raft peer互相通信会死锁
2. 投票term需要检查，因为RPC调用时无锁，可能调用后原来期望的变量已经改变，因此需要检查对应变量，比如检查自己还是不是candidate以及当前的投票term。

**课上讲的Debug工具：**

1. go run -race xx
2. ctrl + / 打印调用栈(同时终止进程)，检查死锁工具
3. 一般都采用print打印

**论文博客阅读心得：**

1. raft论文的fig2 每一个都是必要的，不要去想当然，每一个流程甚至顺序都有其内在道理
2. fig8的不一致问题，通过规定这样的规则解决：leader只能提交自己任期的log entry或者连带提交前面的log entry。这个问题的产生是因为新leader没有拥有全部的commitable的log，通过这条规则解决。
3. commit的时机：满足2的规则并且majority server已经回复了Append RPC，确定了该log已经被其他server复制好，则直接commit该log。接着便可回复client
4. follower这些情况下会补给candidate投票：1.log不是up-to-data（这个的理解很重要，更新指的是candidate最后一个log 的 term 至少要和follower的相同，并且长度(index)还不能比follower长；2. candidate对应的term要大于follower的current term。都满足才会给你投票

**实现心得：**

1. 分布式编写，细节才是魔鬼，最大的困难一定是对原理的理解，比如对raft论文的深刻理解和仔细阅读，比如你身处某个状态(leader or follower)，在什么情况下会做什么事情，一定要细心的去实现
2. 次要困难是具体实现，比如RPC调用时加了锁造成某些情况下的死锁，又比如在一个连续的函数中，中间存在锁的释放，重新获得锁前没去检查之前的变量是否修改，造成难以发现的bug
3. 日志最好分几种，有非常详细的，也有不详细的
4. 分布式及其容易写bug，也极难排错，一定要想清楚每一步，比如锁有没有return是释放，会有哪些crash因素造成那些后果
   
   
**Raft 2A：**

* 好像没啥好说的，选举要快，一个任期只能一个leader，主要困难还是一开始对go语言的陌生
  
**Raft 2B:**
* 我快速找到冲突日志的方法，是客户直接把自己commit的地方发给leader，能一次就搞定，效率很高，代码逻辑也清晰的多; 

**Raft 2C:**
* 没什么难度，每次修改了需要持久的变量时，就persist()一下
* 跟论文不同-我把commitIndex变成持久变量，这样在crash重启时，可以不用重头开始发，显著减少网络流量

**Raft 2D**
* 难度很大，需要对日志压缩(快照)理解的很透彻才能写出正确的代码
  
  > 几乎整个代码全部检查修改了一遍，就因为logs结构变化导致全体改变，边界问题也是很麻烦

主要是清晰理解架构图：

>nil.csail.mit.edu/6.824/2021/notes/raft_diagram.pdf

**分层结构：**

Client <----> Service(State Machine) <----> Raft

基本逻辑：客户端的命令首先由Service层转发给Raft层，Raft层处理确认无误了（即raft节点commit对应命令后）,便提交给Service层，Service层将其应用到状态机里。在某个时刻(由Service层决定)创建一个当前状态机的快照，然后将快照信息的二进制文件发送给Raft层，告知已经将多少Index索引之前的logs写到了快照文件里了，Raft层便可以持久化它到磁盘，然后丢弃对应了冗余logs，即释放了内存。

启动阶段：Raft和Service层分别读快照，Raft将lastApplied变量设为快照对应的最后一个log索引，然后Raft之后只需向Service层提交快照之后的logs。


**注意事项：**

1. Raft层向Service层提交快照仅仅可能发生在Leader调用InstallSnapshot RPC时，即Leader发给了自己一个快照时。然后Service层收到此快照会调用CondInstallSnap通知Raft是否要应用快照，Raft检测其当前的情况，这个通知是不是过期的，如果是，则丢弃->我的实现保证了可以永远直接返回true,因为service层应用快照之前绝不会发新命令给Raft。
2. Leader绝不会向Service层发送快照信息ApplyMsg
3. 所有的日志索引位置都要改，写了个工具包raft_util，将global index和现在的index一一转换，这个工作极度伤神。
4. 测试2D-3出现了严重的死锁，经过长时间排查发现是有些return语句前忘记解锁

**代码重构：**

重构为三大板块对应四个小lab，其中持久化就和raft放一起了，重构后代码结构清晰很多。

